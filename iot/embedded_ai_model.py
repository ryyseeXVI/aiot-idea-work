"""
Embedded AI Model for ESP32
Ultra-lightweight quantized neural network for relay prediction
"""
import math
from typing import List, Tuple, Union

# Feature normalization constants
FEATURE_MEANS = [25.448, 62.336, 600.06, 0.5, 0.52, 0.5]
FEATURE_STDS = [2.5292087, 10.758769, 116.43014, 0.5, 0.49959984, 0.5]

# Quantized model weights and biases
MODEL_DATA = {
    'layer_0': {
        'weights': [[102, 43, 50, -100, -17, -8], [-100, 6, -119, -45, -1, -51], [-51, 77, 67, -79, -58, -3], [39, 36, 12, -38, 67, 32], [84, 9, -40, -12, -112, 7], [96, 42, 30, 30, -57, -101], [29, 109, 53, -115, -25, 44], [-103, 10, -63, -1, 61, -48], [23, -10, 126, 127, 51, 20], [-92, -63, -63, -21, 101, -70], [19, 81, -29, 109, 113, -31], [-23, -69, -36, -106, -102, 29], [-24, 23, -77, 41, -79, -63], [-25, 22, 20, -35, -52, -34], [67, -24, 78, 61, 118, 90], [-21, -98, 58, 12, 90, -90], [75, -29, -36, -13, 8, 22], [29, -119, -57, -55, 120, 81], [-67, 89, 18, -54, -71, 9], [-84, 43, 23, -55, -62, -68], [65, -66, -15, 50, 83, -21], [75, -41, -31, -78, -79, 101], [-41, 105, -64, -17, 56, -35], [35, 23, 40, -61, -1, 63], [22, -24, -75, 73, 72, -59], [91, 9, -48, -38, -61, 90], [116, -71, -36, -85, -61, 33], [2, 101, 87, -68, -44, -101], [-20, -66, 59, 60, 41, 12], [91, -34, -72, -22, -100, 44], [54, 0, -69, 58, 25, 69], [30, 81, -112, -59, 24, 88]],
        'scale': 0.0040249330922961235,
        'biases': [-0.2774156332015991, 0.19293533265590668, -0.3187398910522461, -0.3231581151485443, 0.3613159954547882, 0.24947527050971985, -0.30630409717559814, 0.2369108945131302, -0.009315342642366886, 0.23358464241027832, 0.09027522802352905, 0.29051780700683594, 0.07092778384685516, 0.4253053069114685, -0.1350288689136505, -0.08631633222103119, -0.13845738768577576, 0.4320112466812134, -0.16903075575828552, 0.05789049714803696, 0.007659902796149254, 0.1286563277244568, 0.09221164882183075, 0.12900809943675995, -0.3931276500225067, -0.11114099621772766, -0.05486540123820305, -0.17698001861572266, 0.15733298659324646, -0.13321492075920105, -0.15657494962215424, 0.4256347119808197]
    },
    'layer_1': {
        'weights': [[64, -9, 6, 3, 87, -4, 10, -24, -36, -52, -65, 5, -39, 50, -29, 44, -14, -1, -25, -30, -43, 104, 16, 11, -17, 115, 16, 31, -72, -5, -15, 68], [33, 12, 17, -12, 71, 51, 39, -20, -53, -28, -4, 67, -28, 36, 60, 56, -18, 21, -39, -8, -44, -8, 21, -6, -16, -2, 101, -38, -61, 58, -35, 24], [-60, 44, 47, 49, -64, 27, -86, 62, 25, 70, -33, -10, -65, -39, 79, 1, -25, 0, 36, 18, 90, -2, -24, 49, -10, -92, 0, -46, 59, 7, -3, 25], [-43, 7, 18, 35, -46, 78, -43, 92, 111, 10, 78, 27, 28, -27, 62, 8, -18, 39, -34, -23, -3, -62, -27, -33, 25, -13, -19, 48, -6, -35, 49, 53], [65, -58, -18, 23, 38, -1, -3, 33, -32, 32, 17, 77, 12, -4, 33, -56, -27, 18, 9, 1, -35, 30, 19, 81, 50, 2, -23, 78, -34, 8, 17, -32], [-6, 32, -66, 51, 1, 17, -5, -20, 37, 91, 39, -29, -53, -45, 12, 12, -48, 55, -7, -27, 15, 1, -13, 31, -34, -48, -71, 0, -18, -46, 40, 28], [111, -3, -23, 58, -10, 63, -2, 19, -78, -31, -36, 77, -19, 22, 22, 17, 107, -3, 80, 50, -5, 87, -79, 88, -90, 41, 55, -36, 42, 118, -21, 3], [-5, -32, -21, -2, 71, 50, 97, -7, 10, -43, -35, 40, 26, 52, 17, -16, 9, 54, -49, 5, -10, 6, 4, 5, -24, 105, 78, -49, -85, 39, -25, 67], [19, -84, -52, 24, -13, 81, -54, -51, 75, -28, 70, -51, 25, 56, 42, -28, -55, -41, 7, -31, -13, -3, -53, -33, -10, -3, -19, -10, 43, 5, 3, -20], [34, 11, 16, 50, 32, -5, -29, -36, 58, 89, 25, 18, 59, 53, 82, 40, 43, 15, 39, 38, 88, -56, 21, -25, -15, -89, -19, 2, 11, 15, -13, 31], [-72, 22, 10, 15, -28, 62, -28, -6, 94, -52, -26, -14, 0, 23, 6, -12, -37, -21, 54, -2, 31, 37, 9, 10, -39, -34, -12, -27, -32, 28, -63, -12], [9, -28, 72, -54, -12, -14, 17, 11, -6, -29, 12, 6, -52, -22, 43, -53, 18, -5, 79, 34, -69, -27, -13, -31, -4, 46, -39, 85, 8, 46, -62, -48], [9, -19, -32, 26, 95, 34, 116, 15, -69, -3, -55, 48, -32, 6, 17, -35, -22, 43, -24, -45, -62, -1, -51, 70, 32, 87, 22, 91, -24, 127, 2, 45], [38, 56, 2, -31, -31, 70, -7, 40, 78, 31, 39, -44, 56, -56, -21, 6, -34, 82, -24, -56, -8, -86, -41, -57, 32, -54, 32, 52, -2, -36, -20, 37], [10, 10, 4, 29, 56, 4, 98, -12, 22, -51, -68, 72, 13, 17, -8, -13, 50, 39, -11, -4, -14, 48, -1, -27, -50, 87, 76, 0, -36, 15, 31, 11], [16, 19, 26, 51, 32, 2, 76, 12, -21, 2, -57, 5, 44, 32, 12, 32, 21, -10, 27, -16, 12, 15, -73, 62, 0, -17, 67, 58, -39, 41, 1, 8]],
        'scale': 0.0026431153528392315,
        'biases': [0.07191664725542068, -0.1037587970495224, 0.17336353659629822, -0.025863781571388245, -0.024692563340067863, 0.20438849925994873, -0.013442973606288433, -0.04987788200378418, 0.1629042625427246, 0.012945414520800114, 0.08895906060934067, 0.006895009893923998, 0.0052342601120471954, 0.2298668622970581, 0.032429248094558716, -0.09722186625003815]
    },
    'layer_2': {
        'weights': [[120, 56, -43, -112, 21, -127, 51, 66, -51, -74, -75, 48, 53, -106, 115, 23]],
        'scale': 0.002400715835392475,
        'biases': [0.13705305755138397]
    },
}

def relu(x):
    return max(0, x)

def sigmoid(x):
    if x > 500:
        return 1.0
    if x < -500:
        return 0.0
    return 1.0 / (1.0 + math.exp(-x))

def ai_predict(features: List[float]) -> Tuple[bool, float]:
    """
    Ultra-lightweight AI prediction for relay control.
    
    Args:
        features: [temperature, humidity, vibration, water_leak, time_hour, energy_cost]
    
    Returns:
        Tuple of (should_activate_relay, confidence_score)
    """
    # Normalize features
    normalized = [(f - m) / s for f, m, s in zip(features, FEATURE_MEANS, FEATURE_STDS)]
    
    # Forward pass
    activations = normalized[:]
    
    for layer_idx in range(len(MODEL_DATA)):
        layer_data = MODEL_DATA[f'layer_{layer_idx}']
        weights = layer_data['weights']
        scale = layer_data['scale']
        biases = layer_data['biases']
        
        # Matrix multiplication with quantized weights
        new_activations = []
        for out_idx in range(len(biases)):
            sum_val = biases[out_idx]
            for in_idx in range(len(activations)):
                weight = weights[out_idx][in_idx] * scale
                sum_val += activations[in_idx] * weight
            
            # Apply activation function
            if layer_idx < len(MODEL_DATA) - 1:  # Hidden layers
                new_activations.append(relu(sum_val))
            else:  # Output layer
                new_activations.append(sigmoid(sum_val))
        
        activations = new_activations
    
    confidence = activations[0]
    decision = confidence > 0.5
    return decision, confidence

# Example usage:
# decision, confidence = ai_predict([25.5, 65.0, 600, 0, 1, 0])
# print(f"Relay: {'ON' if decision else 'OFF'}, Confidence: {confidence:.3f}")
